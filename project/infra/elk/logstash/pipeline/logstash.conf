# logstash.conf — Pino (Fastify) normalization (ECS-ish)

input {
  beats { port => 5044 }
}

filter {
  ############################################################
  # 0) Nettoyage basique des champs string (Docker ajoute \n)
  ############################################################
  if [log] and [log] =~ "\n$" {
    mutate { gsub => [ "log", "\n$", "" ] }
  }
  if [message] and [message] =~ "\n$" {
    mutate { gsub => [ "message", "\n$", "" ] }
  }

  ############################################################
  # 1) JSON de secours si Filebeat n'a pas parsé
  #    -> essayer d'abord [message], sinon [log]
  ############################################################
  if ![level] and ![msg] and ![req] and ![pino][event] {
    # Fallback 1 : message contient du JSON
    if [message] and [message] =~ '^\s*\{' {
      json { source => "message" target => "" }
    }
    # Fallback 2 : log contient du JSON (cas Docker très fréquent)
    else if [log] and [log] =~ '^\s*\{' {
      json { source => "log" target => "" }
    }
  }

  ############################################################
  # 2) service.name depuis labels Docker si manquant
  ############################################################
  if ![service][name] and [container][labels][com_docker_compose_service] {
    mutate { add_field => { "[service][name]" => "%{[container][labels][com_docker_compose_service]}" } }
  }

  ############################################################
  # 3) @timestamp depuis Pino "time"
  ############################################################
  if [time] {
    if [time] =~ "^\d+$" {
      date { match => [ "time", "UNIX_MS" ] target => "@timestamp" timezone => "UTC" }
    } else {
      date { match => [ "time", "ISO8601" ] target => "@timestamp" timezone => "UTC" }
    }
  }

  ############################################################
  # 4) log.level depuis Pino level + message lisible
  ############################################################
  if [level] and ![log][level] { mutate { add_field => { "[log][level]" => "%{[level]}" } } }
  if [log][level] { mutate { lowercase => [ "[log][level]" ] } }

  if [msg] { mutate { replace => { "message" => "%{[msg]}" } } }

  ############################################################
  # 5) Mapper champs à plat -> req./res. (compat)
  ############################################################
  if [method] and ![req][method] { mutate { add_field => { "[req][method]" => "%{[method]}" } } }
  if [url] and ![req][url]       { mutate { add_field => { "[req][url]"    => "%{[url]}"    } } }

  if [statusCode] and ![res][statusCode] {
    mutate { add_field => { "[res][statusCode]" => "%{[statusCode]}" } }
  }
  if [res][statusCode] {
    mutate { convert => { "[res][statusCode]" => "integer" } }
  }

  ############################################################
  # 6) ECS-ish HTTP (très utile pour Kibana)
  ############################################################
  if [method] and ![http][request][method] {
    mutate { add_field => { "[http][request][method]" => "%{[method]}" } }
  }

  # Ton plugin met parfois url.path déjà. Si pas présent, on le remplit depuis "url" string.
  if ![url][path] and [url] {
    mutate { add_field => { "[url][path]" => "%{[url]}" } }
  }

  if [statusCode] and ![http][response][status_code] {
    mutate { add_field => { "[http][response][status_code]" => "%{[statusCode]}" } }
    mutate { convert   => { "[http][response][status_code]" => "integer" } }
  }

  ############################################################
  # 7) event.action
  # - priorités :
  #   a) pino.event s'il existe
  #   b) sinon http_access si on voit une méthode
  ############################################################
  if [pino][event] and ![event][action] {
    mutate { add_field => { "[event][action]" => "%{[pino][event]}" } }
  }

  if ![event][action] and ([req][method] or [method] or [http][request][method]) {
    mutate { add_field => { "[event][action]" => "http_access" } }
  }

  ############################################################
  # 8) event.dataset par défaut
  ############################################################
  if ![event][dataset] and [service][name] {
    mutate { add_field => { "[event][dataset]" => "%{[service][name]}" } }
  }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "${ELASTIC_USER:elastic}"
    password => "${ELASTIC_PASSWORD}"
    index => "filebeat-%{+YYYY.MM.dd}"
  }
}
